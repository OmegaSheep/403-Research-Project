/* Skip List by Aedan Burnett */

#include <iostream>
#include <string>
#include <queue>
#include <vector>
#include <algorithm>
#include <sstream>
#include <stdio.h>
#include <stdlib.h>
#include <bitset>
#include <tuple>
#include <cmath>
#include <utility>
#include <string>
#include <climits>

#define MAXLEVEL 10
#define PROB 2
using namespace std;

typedef struct skipNode {
	int value;
	int height;
	struct skipNode *up;
	struct skipNode *down;
	struct skipNode *right;
	struct skipNode *left;

	skipNode(int v) : value(v) {}
} skipNode;

typedef struct skipList {
	int height = 0;
	int size = 0;

	skipNode *head = new skipNode(INT_MIN);
	skipNode *tail = new skipNode(INT_MAX);

} skipList;

int skipSearch(skipList *current, int key) {
	int position = 0;
	skipNode *search = current->head;

	while (search->down != NULL) {
		search = search->down;
		while (key >= search->right->value) {
			search = search->right;
			cout << "Search went right.\n";
			position++;
		}
	}
	if (position-1 < 0) position+=1;
	return position-1;
}

/* Old insert code. Needs improvement*/
void insert(skipList *current, int data) {
	skipNode *newNode = new skipNode(data);

	skipNode *first = current->head;

	while(first->height != 0) {
		first = first->down;
	}

	while (data > first->value) {
		first = first->right;
	}
	newNode->left = first->left;
	(first->left)->right = newNode;
	first->left = newNode;
	newNode->right = first;
	current->size++;


	int coin;
	skipNode *temp = newNode;

	//Loop for stacking a node.
	while (1) {
		coin = rand() % 2;

		//If Coin Flip is bad we exit.
		if (!coin) break;

		//Stacking code.
		else {
			//Stack layer on top of newNode.
			skipNode *layer = new skipNode(data);
			temp->up = layer;
			layer->down = temp;
			layer->height = temp->height+1;

			/*Find layers left node*/
			while (layer->down != NULL) {
				layer = layer->down;
			}	

			while (layer->height != temp->height+1) {
				layer = layer->left;
				while (layer->up != NULL 
					and layer->height != temp->height+1) {
					layer = layer->up;
				}
			}

			temp->up->left = layer;
			layer->right = temp->up;
			layer = temp->up;

			/*Find layers right node */
			while (layer->down != NULL) {
				layer = layer->down;
			}	

			while (layer->height != temp->height+1) {
				layer = layer->right;
				while (layer->up != NULL 
					and layer->height != temp->height+1) {
					layer = layer->up;
				}
			}

			temp->up->right = layer;
			layer->left = temp->up;

			/*Temp is now the stacked layer*/
			temp = temp->up;
		}
		if (temp->height >= MAXLEVEL-1) {
			break;
		}
	}
}

/*
void insert2(skipList *current, int data) {
	skipNode *newNode = new skipNode(data);
	skipNode *indexer = current->head;
	int p = skipSearch(current,data);
	
	//Get to the bottom layer.
	while (indexer->down != NULL) {
		indexer = indexer->down;
	}
	//Insert item in bottom layer.
	for (int i=0; i<p; ++i) {
		indexer = indexer->right;
	}
	cout << "i value: " << p << "\n";
	indexer = indexer->right;
	newNode->left = indexer->left;
	indexer->left->right = newNode;
	
	indexer->left = newNode;
	newNode->right = indexer;
	current->size++;
}
*/

//Prints out the top layer.
void print1(skipList *current) {
	if (current->size == 0) {
		return;
	}

    skipNode *node = current->head;
    while(node->right != current->tail) {
    	cout << node->right->value << " ";
    	node = node->right;
    } 
    cout << "\n";
}

//Prints out every layer of the head and tail.
void print2(skipList *current) {
	skipNode *node1 = current->head;
	skipNode *node2 = current->tail;

	cout << "Down swing\n";
	while (node1->down != NULL) {
		printf("Head [Height/Val]: %d %d\n",node1->height,node1->value);
		printf("Tail [Height/Val]: %d %d\n",node2->height,node2->value);
		node1 = node1->down;
		node2 = node2->down;
	}
	printf("Head [Height/Val]: %d %d\n",node1->height,node1->value);
	printf("Tail [Height/Val]: %d %d\n",node2->height,node2->value);

	cout << "Up swing\n";
	while (node1->up != NULL) {
		printf("Head [Height/Val]: %d %d\n",node1->height,node1->value);
		printf("Tail [Height/Val]: %d %d\n",node2->height,node2->value);
		node1 = node1->up;
		node2 = node2->up;
	}
	printf("Head [Height/Val]: %d %d\n",node1->height,node1->value);
	printf("Tail [Height/Val]: %d %d\n",node2->height,node2->value);
	
}

//Prints out the entire skip lists contents.
void print3(skipList *current) {
	skipNode *node1 = current->head;
	
	while (node1->down != NULL) {
		while (node1->right != NULL) {
			cout << node1->value << " ";
			node1 = node1->right;
		}
		cout << node1->value << "\n";
		node1 = node1->down;

		while (node1->left !=NULL) {
			node1 = node1->left;
		}
	}

	while (node1->right != NULL) {
			cout << node1->value << " ";
			node1 = node1->right;
		}
	cout << node1->value << "\n";
}

int main() {

	/*Ensures randomness for insertion.*/
	srand(time(NULL));

	skipList *s = new skipList;

	/*Head is far right. Tail is far left.*/
	s->head->right = s->tail;
	s->tail->left = s->head;

	/*Base layer height is 0.*/
	s->head->height = 0;
	s->tail->height = 0;

	/*Temporary nodes to construct head and tail at all heights.*/
	skipNode *temp1 = s->head;
	skipNode *temp2 = s->tail;
	for (int i = 1; i < MAXLEVEL; ++i) {

		//Create next layer.
		temp1->up = new skipNode(INT_MIN);
		temp2->up = new skipNode(INT_MAX);

		//Set next layer height.
		temp1->up->height = i;
		temp2->up->height = i;

		//Set next layer to be head and tail to each other.
		temp1->up->right = temp2->up;
		temp2->up->left = temp1->up;

		//The new level should refer to the old.
		(temp1->up)->down = temp1;
		(temp2->up)->down = temp2;

		//Set the current node to be the new level.
		temp1 = temp1->up;
		temp2 = temp2->up;
	}
	//Finally. The head should be at the top of the list.
	s->head = temp1;
	s->tail = temp2;

	for (int i = 0; i <= 70; ++i) {
		insert(s,i);
	}
	print3(s);
	//cout << skipSearch(s,2) << "\n";
	//cout << skipSearch(s,8) << "\n";
	//cout << skipSearch(s,10) << "\n";
	//cout << skipSearch(s,5) << "\n";
	
	return 0;
}